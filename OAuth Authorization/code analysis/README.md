## This directory contains the analysis results for each code file to identify misuses of OAuth.

Here, you can find the description of OAuth API as well as its misuses

# OAuth APIs
Open Authorization (OAuth) is a popular authorization protocol enabling end-users to grant third-party websites or applications access to their private resources stored on a remote server without sharing their credentials. This process involves three major roles: the user or resource owner who owns protected resources, the Service Provider (SP) that hosts the resources, and Relying Party (RP), known as client application that uses the SP to obtain access to the user’s resources. Access tokens are issued by SPs to RPs with the owner’s approval for accessing protected resources. OAuth APIs provided by SPs such as Google, Twitter, or Facebook are used by developers to authenticate users or obtain access to users’ resources through their major accounts in SPs. 

Although OAuth was first introduced as an authorization framework, it has been widely adopted to implement Single-Sign-On authentication, making it difficult for developers to use it properly. To address this challenge, OpenID Connect was introduced as an authentication framework based on OAuth. The OAuth specification defines four different protocol flows or grant types: (i) authorization code, (ii) implicit, (iii) resource owner password credentials, and (iv) client credentials. Authorization code grant is the the most commonly used grant type. It begins with a user sending a request to a RP to access a remote resource (step 1). The RP then redirects the user to the SP with an APP ID and an optional state parameter to bind this request (step 2). Next, the user authenticates with the SP and grants the RP’s requested permissions (step 3). The SP issues an authorization code and an optional state parameter to the user (step 4). The user is then redirected back to the RP’s redirection endpoint, where the request is rejected if the received state parameter mismatches the initial one (step 5). Next, the RP sends the authorization code and it’s secret (established during registration with the SP) to the SP to request an access token (step 6). The SP verifies the RP app by validating the App ID and app secret and then responds with an access token (steps 7). With the access token the RP requests user data from the SP, which is then shared with the RP accordingly (steps 8-9).

In the implicit grant (which is simpler than the authorization code grant), in step 4, the SP directly responds with an access token instead of an authorization code, without authenticating the RP. Resource owner password credentials and client credentials grants are rarely used.

# Misuses of OAuth APIs

## 1) Local storage of relying party secrets 
(e.g.,  bundling secrets as field variables, resource files, or constants in code)
Although RP secrets are intended to be used by SPs to authenticate the RP, many developers store these secrets on the client-side application, posing a significant security threat to the user’s privacy. As a result, an attacker could retrieve the secret through reverse engineering, and use it to impersonate a benign application and request an access token from the SPs.
## 2) Local storage of access tokens 
(e.g., storing in filesystem): 
The storage of access tokens is a critical security concern as they provide RPs access to a user’s protected resources hosted by SP. Simply storing them on client devices can easily compromise user accounts. Attackers may steal locally-stored tokens, consequently gaining unauthorized access to user accounts and sensitive information stored in SPs.
## 3) Inadequate transmission protection 
(e.g., transmitting security-sensitive information in plaintext)
OAuth security heavily depends on the secure transmission of messages during the OAuth process. Transmitting messages in plaintext lets attackers eavesdrop and steal access tokens or other OAuth credentials. It is crucial to use SSL/TLS encryption when transmitting confidential information during OAuth transactions to prevent this exploit.
## 4) Lack or misuse of the state parameter 
(e.g., constant values for state)
The state parameter safeguards user sessions against a Cross-Site Request Forgery (CSRF) attacks by verifying request authenticity. In CSRF an attacker uses a user’s previous session data to make a malicious request on their behalf. OAuth guidelines recommend generating and validating a randomized state parameter, bound to the user’s session to prevent such attacks [22]. However, developers may misunderstand its purpose leading to mistakes such as using a predictable or constant value, enabling multiple replays, neglecting state parameter verification, accepting requests without a state parameter, or assuming that all state parameters generated by their app are valid without proper session binding checking.
## 5) Client-side API call 
A significant security concern in OAuth authentication flows arises from the reliance on clientside API calls, which attackers could easily manipulate. Some developers mistakenly assume that access tokens granted by SPs are only valid for their application. However, an attacker can use an access token granted for a malicious application to log in as a user for a different, benign application and gain access to sensitive information.
## 6) Insecure redirection options 
(such as WebView in Android)
To ensure the security of OAuth transactions, it is crucial to use secure methodologies for handling redirection. Insecure redirection methods can allow attackers to redirect users to arbitrary domains or URLs, potentially leading to further attacks or data theft. For instance, in a mobile context, using WebView is considered insecure as it undermines the isolation between a SP and a RP. A malicious RP can use the WebView of their mobile applications to host a SP, allowing them to access the user’s cookies and log in on the user’s behalf.
## 7) Using authorization flows for authentication
OAuth was primarily designed for authorization, and its use for authentication was not explicitly defined in the initial specifications [S30]. Consequently, many developers erroneously adopted authorization flows for authentication purposes [S48]. Particularly, an access token in authorization flows is used as a means of authentication, but the access token only validates the authorization granted to a third-party application and can not provide an accurate representation of the user’s identity.
## 8) Lack of authentication 
In the OAuth transactions, a SP is responsible for authenticating a RP, and reciprocally, a RP is also responsible for authenticating a SP. This verification process can be performed using the same methods by which a SP authenticates a RP application. However, a study conducted by AuthDroid [S47] on a collection of Android apps revealed that none of the RP apps in their investigation verified the SP’s identity.
## 8) Lack of PKCE parameters for authorization code grant
The authorization code grant is generally considered to be the most secure OAuth grant type. However, it is still susceptible to code interception attacks, where an attacker intercepts the authorization code sent by the SP and uses it to obtain an access token [52]. To mitigate this vulnerability, the Proof Key for Code Exchange (PKCE) protocol was introduced in the OAuth 2.0 specification [53]. PKCE verifies that the requesting application is the same one that originally requested the authorization code by using a cryptographically linked code verifier and code challenge exchanged between the application and the SP. PKCE is recommended as a mandatory security measure for public clients to enhance the security of the authorization code grant.
## 9) Insecure grant types
The security of an OAuth transaction highly depends on the choice of grant type. It is essential to avoid using insecure grant types such as implicit for authentication. Implicit grants raise a major security concern because the access token is not bound to the intended RP which enables an attacker to use a user’s access token, issued to the malicious application, to log in as the user on a benign application [S48]. Best current practices recommend using the authorization code flow, which can be protected by PKCE, as a more secure alternative to other grant types [S54]
